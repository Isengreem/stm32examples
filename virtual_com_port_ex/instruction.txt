http://narodstream.ru/stm-urok-33-hal-usb-virtual-com-port/

Есть несколько типов решений, мне понравился именно этот, т.к. более простой: в файле usbd_cdc.h заменим размер пакета, вместо 512 напишем 256 в данной строке:

 

#define CDC_DATA_HS_MAX_PACKET_SIZE                 256  /* Endpoint IN & OUT Packet size */

 

Соберём, прошьём и увидим, что ошибка исчезла.

Начнём писать код.

Сначала попытаемся передать данные на ПК.

Для этого мы сначала откроем файл usbd_cdc_if.c и исправим там в 2х строчках 4 на 64

 

/* It's up to user to redefine and/or remove those define */

#define APP_RX_DATA_SIZE  64

#define APP_TX_DATA_SIZE  64

 

В файле main.c закомментируем весь пользовательский код кроме инициализации и очистки дисплея

 

  /* USER CODE BEGIN 2 */

        LCD_ini();

//        sprintf(str,"Stm32F407VG");

//        LCD_String(str);

//        LCD_SetPos(10, 2);

//        sprintf(str,"ARM mc");

//        LCD_String(str);

//        HAL_Delay(2000);

        LCD_Clear();

//        LCD_SetPos(4, 0);

//        LCD_SendChar('s');

//        LCD_SetPos(8, 1);

//        LCD_SendChar('t');

//        LCD_SetPos(12, 2);

//        LCD_SendChar('m');

//        LCD_SetPos(16, 3);

//        LCD_SendChar('3');

//        LCD_SendChar('2');

//        HAL_Delay(2000);

  /* USER CODE END 2 */

 

 

Также в main.c подключим файл usbd_cdc_if.h для видимости функций приема и передачи

 

/* USER CODE BEGIN Includes */

#include "main.h"

#include "usbd_cdc_if.h"

 

Немного изменим в главной функции строковую переменную, убавив в ней размер и добавив префикс tx

 

  /* USER CODE BEGIN 1 */

        char str_tx[21];

  /* USER CODE END 1 */

 

В файле usbd_cdc_if.c добавим прототип функции передачи, скопировав объявление из реализации данной функции в том же файле

 

/* USER CODE BEGIN PRIVATE_FUNCTIONS_DECLARATION */

uint8_t CDC_Transmit_FS(uint8_t* Buf, uint16_t Len);

/* USER CODE END PRIVATE_FUNCTIONS_DECLARATION */

 

В main() внесём данные в строку

 

        sprintf(str_tx,"USB Transmit\r\n");

  /* USER CODE END 2 */

 

В бесконечном цикле попробуем эти данные отправить в порт USB, используя функцию, прототип которой мы добавили

 

  while (1)

  {

                CDC_Transmit_FS((unsigned char*)str_tx, strlen(str_tx));

                HAL_Delay(500);

  /* USER CODE END WHILE */

 

Соберём код, прошьём контроллер и посмотрим результат в терминальной программе.

Вроде передать нам что-то удалось. Теперь попробуем что-нибудь принять. Здесь чуть посложнее, т.к. для этого используется уже обработчик прерывания, коим является в файле usbd_cdc_if.c функция CDC_Receive_FS.

Добавим ещё одну строковую глобальную переменную в main()

 

/* USER CODE BEGIN PV */

/* Private variables ———————————————————*/

char str_rx[21];

/* USER CODE END PV */

Объявим её также и в файле usbd_cdc_if.c

/* USER CODE BEGIN PRIVATE_VARIABLES */

extern char str_rx[21];

/* USER CODE END PRIVATE_VARIABLES */

 

В функцию CDC_Receive_FS в этом же файле добавим некоторый код и кое-что закомментируем

 

static int8_t CDC_Receive_FS (uint8_t* Buf, uint32_t *Len)

{

  /* USER CODE BEGIN 6 */

  //USBD_CDC_SetRxBuffer(&hUsbDeviceFS, &Buf[0]);

        strncpy(str_rx,(char*)Buf,*Len);

        str_rx[*Len]=0;

  USBD_CDC_ReceivePacket(&hUsbDeviceFS);

  return (USBD_OK);

Добавим переменную в main()

  /* USER CODE BEGIN 1 */

        uint8_t i=0;

        char str_tx[21];

 

Занесенные в наш буфер данные попробуем вывести на дисплей, для этого в бесконечном цикле в функции main() добавим определённый код

 

  while (1)

  {

                CDC_Transmit_FS((unsigned char*)str_tx, strlen(str_tx));

                LCD_SetPos(0, 0);

                LCD_String(str_rx);

                for(i=1;i<((uint8_t)(20-strlen(str_rx)));i++) LCD_SendChar(' ');

                HAL_Delay(500);

 

Соберём проект. Прошьём код и посмотрим результат, вводя в терминальной программе и отправляя в порт USB какие-нибудь строки.